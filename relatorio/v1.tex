\chapter{Primeira versão}
Comecemos por analisar, quanto ao número de vértices visitados, o 1º algoritmo desenvolvido, que utiliza
uma cópia do grafo original para calcular a sua ordenação
topológica.

O algoritmo começa por percorrer todos os vértices até encontrar
um que ainda não tenha sido marcado e cujo \verb|InDegree| seja
0.


\section{Análise Informal}

Para realizar a análise informal do algorítmo, necessitamos de
contadores que registem as métricas adotadas. Analisando do
algoritmo quanto ao número de vértices visitados, então teremos
que incrementar um contador sempre que visitarmos um novo
vértice. Contudo, a \verb|performance| do algoritmo será ditada
por mais fatores do que apenas o número de vértices que este
visitou, pelo que iremos ter também contadores para o número de
arestas removidas, o número de comparações efetuadas entre o
\verb|InDegree| de cada vértice e o número de alocações de
memória efetuadas.

No final da execução do programa, teremos que imprimir para a
consola ou para um ficheiro o valor presente em cada contador.

\begin{listing}[H]
	\centering
	\begin{minted}{text}
            Verts	         Edges	          Cmps
SWtinyDAG:    104	            15	           104
  \end{minted}
	\caption{Contadores no final da execução do primeiro algoritmo}
\end{listing}

Contudo, para tirar alguma conclusão significativa, teremos que
utilizar mais do que um grafo, e estes têm que ser semelhantes.
Iremos então para comparações seguintes utilizar grafos em que
cada vértice $i$ possui uma aresta para o vértice $i+1$


Vejamos então o resultado para tais grafos com diferente número
de vértices

\begin{listing}[H]
	\centering
	\begin{minted}{text}
                    Verts	         Edges	          Cmps
1024 vértices:     526850	          1024	        526850
2048 vértices:    2102274	          2048	       2102274
4096 vértices:    8398850	          4096	       8398850
8192 vértices:   33574914	          8192	      33574914
16384 vértices: 134258690	         16384	     134258690
  \end{minted}
	\caption{Contadores no final da execução do primeiro algoritmo
		para grafos "sequenciais"}
\end{listing}

Para, de modo experimental, calcular a complexidade do algoritmo,
podemos calcular o coeficiente entre $T(2N)$ e $T(N)$ para uma dada métrica, de modo a
estimar a sua classe de eficiência.

Em cada um dos casos da tabela obtida, o quociente da divisão
será aproximadamente 4, sendo mais próximo de 4 quanto maior o
número de vértices em cada grafo. Como tal, podemos concluir que
a ordem de complexidade do algoritmo para o tipo de grafos em
causa será aproximadamente $\mathcal{O}(n^2)$

Note-se também que o número de comparações efetuadas é igual ao
número de vértices visitados, conclusão que é algo relativamente
óbvio de compreender, uma vez que por cada vértice que visitamos
temos que verificar se o seu \verb|InDegree| é 0, ou se o vértice
já foi marcado.

Contudo, a experiência realizada não nos permite concluir se o
número de arestas de saída em cada vértice possui algum impacto
no número de vértices visitado. Para tal, realizemos a mesma
experiência, só que agora cada vértice $i$ possui uma aresta para
o vértice $i + 1$ e para o vértice $i + 2$.

\begin{listing}[H]
	\centering
	\begin{minted}{text}
                    Verts	         Edges	          Cmps
1024 vértices:     526850	          2046	        526850
2048 vértices:    2102274	          4094	       2102274
4096 vértices:    8398850	          8190	       8398850
8192 vértices:   33574914	         16382	      33574914
16384 vértices: 134258690	         32766	     134258690
  \end{minted}
	\caption{Contadores no final da execução do primeiro algoritmo
		para grafos "sequenciais"}
\end{listing}

O número de vértices visitados é igual, tal como o número de
comparações efetuadas. A diferença, como seria de esperar, reside
apenas no número de arestas visitadas. Como todos os vértices
possuem agora um \verb|InDegree| de 2, exceto os 2 primeiros
vértices, então o número de arestas visitadas corresponde ao
número de arestas existentes no grafo. Como tal, podemos concluir
que o número de arestas não afeta o número de vértices visitados.

\section{Análise Formal}

Façamos então uma análise formal do caso anterior, de modo a
verificar se a conclusão obtida é verídica ou não.


Sabemos que o algorítmo percorre, até que não haja vértices
restantes, todos os vértices de modo
sequencial até encontrar um vértice não visitado cujo
\verb|InDegree|, e que por cada vértice válido encontrado, irá
iterar por todas as suas arestas de saída.

Iterar até que não haja mais vértices restantes é uma operação de
ordem linear (Iremos ter que iterar todos os vértices).

A cada nova iteração, temos que selecionar um novo vértice
válido, ou seja, não marcado e cujo \verb|InDegree| seja 0. Isto
involve, no pior dos casos, iterar todos os vértices uma vez
mais.

Por fim, após a seleção de um vértice válido, iremos ter que
iterar por todas as suas arestas de saída. Note-se que isto
resulta em percorrer todas as arestas do grafo.

Consideremos então V como sendo o número de vértices do grafo, e
E como sendo o númerp de arestas exeistentes no grafo. Traduzindo o referido anteriormente num somatório, obtemos:

\begin{listing}[H]
	\begin{align}
		 & \sum_{i = 0}^{V} \sum_{j=0}^{V} (1 + \sum_{k=0}^{deg(v)}) =
		\\
		 & \sum_{i = 0}^{V} \sum_{j=0}^{V} 1 + \sum_{j=0}^{V}
		\sum_{k=0}^{deg(v)}                                            \\
		 & \sum_{i=0}^{V} (V + E)                                      \\
		 & V(V+E)
	\end{align}
	\caption{Complexidade do pior caso}
\end{listing}

Como tal, calculámos o número de iterações realizado no pior dos
casos do algorítmo e podemos concluir que a sua complexidade é
$\mathcal{O}(V(V+E))$, equivalente a $\mathcal{O}(V^2+(V \cdot
	E))$
